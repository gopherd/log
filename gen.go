// +build gopherdloggen

// command to generate types.go
//
//	go run gen.go > types.go
//
package main

import (
	"fmt"
	"strings"
)

type scalar struct {
	name string
}

func (s scalar) sliceName() string { return strings.Title(s.name) + "s" }
func (s scalar) isInt() bool       { return strings.HasPrefix(s.name, "int") }
func (s scalar) isUint() bool      { return strings.HasPrefix(s.name, "uint") }
func (s scalar) isFloat() bool     { return strings.HasPrefix(s.name, "float") }
func (s scalar) isComplex() bool   { return strings.HasPrefix(s.name, "complex") }
func (s scalar) bits() int {
	switch s.name {
	case "float32", "complex64":
		return 32
	case "float64", "complex128":
		return 64
	default:
		return 0
	}
}

func t(name string) scalar {
	return scalar{
		name: name,
	}
}

func p(a ...interface{}) {
	for i := range a {
		fmt.Print(a[i])
	}
	fmt.Println("")
}

func main() {
	types := []scalar{
		t("int"), t("int8"), t("int16"), t("int32"), t("int64"),
		t("uint"), t("uint8"), t("uint16"), t("uint32"), t("uint64"),
		t("float32"), t("float64"),
		t("complex64"), t("complex128"),
		t("bool"), t("string"), t("byte"),
	}
	p("// Auto-generated by gen.go, DON'T EDIT IT!")
	p("package log")
	p()
	p("import \"strconv\"")
	p()
	for _, t := range types {
		p("type ", t.sliceName(), " []", t.name)
	}

	for _, t := range types {
		p()
		p("func (s ", t.sliceName(), ") AppendFormat(buf []byte) []byte {")
		if t.name != "byte" {
			p("\tbuf = append(buf, '[')")
		} else {
			p("\tbuf = append(buf, '0', 'x')")
		}
		p("\tfor i := range s {")
		if t.name != "byte" {
			p("\t\tif i > 0 {")
			p("\t\t\tbuf = append(buf, ',')")
			p("\t\t}")
		}
		if t.isInt() {
			p("\t\tbuf = strconv.AppendInt(buf, int64(s[i]), 10)")
		} else if t.isUint() {
			p("\t\tbuf = strconv.AppendUint(buf, uint64(s[i]), 10)")
		} else if t.isFloat() {
			p("\t\tbuf = strconv.AppendFloat(buf, float64(s[i]), 'f', -1, ", t.bits(), ")")
		} else if t.isComplex() {
			p("\t\tre, im := float64(real(s[i])), float64(imag(s[i]))")
			p("\t\tif re != 0 {")
			p("\t\t\tbuf = strconv.AppendFloat(buf, re, 'f', -1, ", t.bits(), ")")
			p("\t\t}")
			p("\t\tif im != 0 {")
			p("\t\t\tif re != 0 {")
			p("\t\t\t\tbuf = append(buf, '+')")
			p("\t\t\t}")
			p("\t\t\tbuf = strconv.AppendFloat(buf, im, 'f', -1, ", t.bits(), ")")
			p("\t\t\tbuf = append(buf, 'i')")
			p("\t\t} else if re == 0 {")
			p("\t\t\tbuf = append(buf, '0')")
			p("\t\t}")
		} else if t.name == "bool" {
			p("\t\tbuf = strconv.AppendBool(buf, s[i])")
		} else if t.name == "string" {
			p("\t\tbuf = strconv.AppendQuote(buf, s[i])")
		} else if t.name == "byte" {
			p("\t\th, l := s[i]>>4, s[i]&0xF")
			p("\t\tbuf = append(buf, hex[h], hex[l])")
		}
		p("\t}")
		if t.name != "byte" {
			p("\tbuf = append(buf, ']')")
		}
		p("\treturn buf")
		p("}")
	}
}
