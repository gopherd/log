// Auto-generated by genslice.go, DON'T EDIT IT!
package log

func (ctx *Context) Ints(key string, value []int) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeInts(value)
	}
	return ctx
}

func (ctx *Context) Int8s(key string, value []int8) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeInt8s(value)
	}
	return ctx
}

func (ctx *Context) Int16s(key string, value []int16) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeInt16s(value)
	}
	return ctx
}

func (ctx *Context) Int32s(key string, value []int32) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeInt32s(value)
	}
	return ctx
}

func (ctx *Context) Int64s(key string, value []int64) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeInt64s(value)
	}
	return ctx
}

func (ctx *Context) Uints(key string, value []uint) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeUints(value)
	}
	return ctx
}

func (ctx *Context) Uint8s(key string, value []uint8) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeUint8s(value)
	}
	return ctx
}

func (ctx *Context) Uint16s(key string, value []uint16) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeUint16s(value)
	}
	return ctx
}

func (ctx *Context) Uint32s(key string, value []uint32) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeUint32s(value)
	}
	return ctx
}

func (ctx *Context) Uint64s(key string, value []uint64) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeUint64s(value)
	}
	return ctx
}

func (ctx *Context) Float32s(key string, value []float32) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeFloat32s(value)
	}
	return ctx
}

func (ctx *Context) Float64s(key string, value []float64) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeFloat64s(value)
	}
	return ctx
}

func (ctx *Context) Complex64s(key string, value []complex64) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeComplex64s(value)
	}
	return ctx
}

func (ctx *Context) Complex128s(key string, value []complex128) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeComplex128s(value)
	}
	return ctx
}

func (ctx *Context) Bools(key string, value []bool) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeBools(value)
	}
	return ctx
}

func (ctx *Context) Strings(key string, value []string) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeStrings(value)
	}
	return ctx
}

func (ctx *Context) Bytes(key string, value []byte) *Context {
	if ctx != nil {
		ctx.encoder.encodeKey(key)
		ctx.encoder.encodeBytes(value)
	}
	return ctx
}

func (enc *encoder) encodeInts(s []int) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeInt(int64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeInt8s(s []int8) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeInt(int64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeInt16s(s []int16) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeInt(int64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeInt32s(s []int32) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeInt(int64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeInt64s(s []int64) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeInt(int64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeUints(s []uint) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeUint(uint64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeUint8s(s []uint8) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeUint(uint64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeUint16s(s []uint16) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeUint(uint64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeUint32s(s []uint32) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeUint(uint64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeUint64s(s []uint64) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeUint(uint64(s[i]))
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeFloat32s(s []float32) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeFloat(float64(s[i]), 32)
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeFloat64s(s []float64) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeFloat(float64(s[i]), 64)
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeComplex64s(s []complex64) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeComplex(float64(real(s[i])), float64(imag(s[i])), 32)
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeComplex128s(s []complex128) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeComplex(float64(real(s[i])), float64(imag(s[i])), 64)
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeBools(s []bool) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeBool(s[i])
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeStrings(s []string) {
	enc.writeByte('[')
	for i := range s {
		if i > 0 {
			enc.writeByte(',')
		}
		enc.encodeString(s[i])
	}
	enc.writeByte(']')
}

func (enc *encoder) encodeBytes(s []byte) {
	enc.writeString("0x")
	for i := range s {
		h, l := s[i]>>4, s[i]&0xF
		enc.writeByte(hex[h])
		enc.writeByte(hex[l])
	}
}
